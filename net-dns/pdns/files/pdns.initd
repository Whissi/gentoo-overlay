#!/sbin/runscript
# Copyright 1999-2015 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: $

PDNS_CONFIGDIR=${PDNS_CONFIGDIR:-"/etc/powerdns"}
PDNS_INSTANCE=${RC_SVCNAME#pdns[.-]}
PDNS_OPTS=${PDNS_OPTS:-""}
PDNS_SSDARGS=${PDNS_SSDARGS:-"--wait 2000"}
PDNS_TERMTIMEOUT=${PDNS_TERMTIMEOUT:-"TERM/30/KILL/5"}

extra_started_commands="dump ping"
extra_stopped_commands="monitor"

description="Authoritative name server"
description_dump="Dumps all powerdns-instance statistic variables"
description_ping="Pings the powerdns-instance"
description_monitor="Starts the powerdns-instance in foreground with logging and console enabled"

command="/usr/sbin/pdns_server"
command_args="${PDNS_OPTS}"
command_args="${command_args} --config-dir=${PDNS_CONFIGDIR}"
command_args="${command_args} --daemon=yes"

control_command="/usr/bin/pdns_control"
control_command_args="--config-dir=${PDNS_CONFIGDIR}"

name="PowerDNS Authoritative Server"
retry=${PDNS_TERMTIMEOUT}
start_stop_daemon_args=${PDNS_SSDARGS}

if [ -n "${PDNS_INSTANCE}" ] && [ "${PDNS_INSTANCE}" != "pdns" ]; then
	PDNS_CONFIGFILE="${PDNS_CONFIGDIR}/pdns-${PDNS_INSTANCE}.conf"
	name="${name} (${PDNS_INSTANCE})"
	command_args="${command_args} --config-name=${PDNS_INSTANCE}"
	control_command_args="${control_command_args} --config-name=${PDNS_INSTANCE}"
else
	PDNS_CONFIGFILE="${PDNS_CONFIGDIR}/pdns.conf"
	name="${name} (default)"
fi

# We cannot use "required_files" because this function will be called
# too late
if [ ! -r ${PDNS_CONFIGFILE} ]; then
	eerror "$RC_SVCNAME: \`${PDNS_CONFIGFILE}' is not readable"
	exit 1
fi

socketdir=$(awk -F= '/^socket-dir=/ {print $2}' "${PDNS_CONFIGFILE}")
if [ -z "${socketdir}" ]; then
	# Default configure value -- see the ebuild
	socketdir="/run"
fi

if [ -n "${PDNS_INSTANCE}" ] && [ "${PDNS_INSTANCE}" != "pdns" ]; then
	pidfile="${socketdir}/pdns-${PDNS_INSTANCE}.pid"
	controlsocket="${socketdir}/pdns-${PDNS_INSTANCE}.controlsocket"
else
	pidfile="${socketdir}/pdns.pid"
	controlsocket="${socketdir}/pdns.controlsocket"
fi

output=
yesno ${rc_verbose} || output='> /dev/null 2>&1'

_is_running() {
	eval ${control_command} \
		${control_command_args} \
		rping $output
	return $?
}

depend() {
	use logger net dns
}

dump() {
	einfo "Dumping statistics from ${name} ..."
	eval ${control_command} \
		${control_command_args} \
		list \
		&& return 0 \
		|| return 0
}

monitor() {
	einfo "Starting ${name} in monitor mode ..."

	echo ""
	echo "**************************************"
	echo "* Use \"QUIT\" to end monitoring mode! *"
	echo "**************************************"
	echo ""

	eval ${command} \
		${command_args} \
		--daemon=no \
		--guardian=no \
		--control-console=yes \
		--loglevel=9 \
		--log-dns-details=yes \
		--query-logging=yes \
		&& return 0 \
		|| return 0
}

ping() {
	ebegin "Pinging ${name}"
	_is_running
	eend $?
}

status() {
	# Based on _status() in /lib/rc/sh/runscript.sh
	# 
	# Important:
	#   When the service uses "guardian=yes" our normal status check
	#   will always pass when the guardian process is up and running.
	#   But this is no indicator for the name service itself, for
	#   example you could have started a second instance which tries
	#   to bind to the default port which is already in use by the
	#   default instance... the guardian process will keep respawning
	#   your new instance so you won't notice a service failure without
	#   examining your system log files.
	if service_stopping; then
		ewarn "status: stopping"
		return 4
	elif service_starting; then
		ewarn "status: starting"
		return 8
	elif service_inactive; then
		ewarn "status: inactive"
		return 16
	elif service_started; then
		if service_crashed; then
			eerror "status: crashed"
			return 32
		elif ! _is_running; then
			eerror "status: not responding"
			return 69
		fi
		einfo "status: started"
		return 0
	else
		einfo "status: stopped"
		return 3
	fi
}

# We are not using "pdns_control quit" to stop the powerdns-instance
# because it is not guaranteed that this method really makes sure that
# the service will be stopped at the end. This is not acceptable because
# this is not reliable.
# OpenRC's default stop method uses start-stop-daemon to bring down the
# service. With its "retry" option it is guaranteed that the service will
# be finally killed after 35 seconds (default).

stop_post() {
	if [ -f "${pidfile}" ]; then
		vebegin "Removing stale pidfile \"${pidfile}\""
		rm -f "${pidfile}"
		veend $? 
	fi

	if [ -S "${controlsocket}" ]; then
		vebegin "Removing stale controlsocket \"${controlsocket}\""
		rm -f "${controlsocket}"
		veend $? 
	fi
}
